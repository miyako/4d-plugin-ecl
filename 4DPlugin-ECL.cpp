/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-ECL.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : ECL
 #	author : miyako
 #	2021/11/16
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-ECL.h"

#pragma mark -

static char *argv = (char *)"lisp";

static void shutdown() {
    cl_shutdown();
}

static void boot() {
    cl_boot(1, &argv);
}

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin:
            case kServerInitPlugin:
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)boot    , NULL);
                break;
                
            case kDeinitPlugin:
            case kServerDeinitPlugin:
                PA_RunInMainProcess((PA_RunInMainProcessProcPtr)shutdown, NULL);
                break;

			// --- ECL
            
			case 1 :
                ecl_import_current_thread(ECL_NIL, ECL_NIL);
				lisp(params);
                ecl_release_current_thread();
				break;

        }

	}
	catch(...)
	{

	}
}

static void get_output(PA_ObjectRef status, const wchar_t *std, cl_object os) {
    
    cl_object o = cl_get_output_stream_string(os);
    CUTF32String u32 = CUTF32String((const ecl_character *)o->string.self, o->string.dim);
    
    uint32_t len = (uint32_t)(u32.length() * sizeof(ecl_character)) + sizeof(ecl_character);
    std::vector<uint8_t> buf(len);
    
    len = PA_ConvertCharsetToCharset(
                                     (char *)u32.data(),
                                     (PA_long32)u32.length() * sizeof(ecl_character),
                                     eVTC_UTF_32,
                                     (char *)&buf[0],
                                     len,
                                     eVTC_UTF_8
                                     );
    std::string u8 = (const char *)&buf[0];
    
    ob_set_s(status, std, u8.c_str());
}

#pragma mark -

void lisp(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    ob_set_b(status, L"success", false);
    
    std::string lisp;
    
    PA_Unistring *arg1 = PA_GetStringParameter(params, 1);
    if(arg1){
        CUTF16String u16 = (const PA_Unichar *)PA_GetUnistring(arg1);
        u16_to_u8(u16, lisp);
    }
    
    uint32_t len = (uint32_t)(lisp.length() * 6 * sizeof(uint8_t)) + sizeof(uint8_t);
    std::vector<uint8_t> buf(len);
    
    len = PA_ConvertCharsetToCharset(
                                     (char *)lisp.data(),
                                     (PA_long32)lisp.length() * sizeof(uint8_t),
                                     eVTC_UTF_8,
                                     (char *)&buf[0],
                                     len,
                                     eVTC_UTF_32
                                     );
    CUTF32String u32 = (const ecl_character *)&buf[0];
    
    cl_object lisp32 = ecl_alloc_simple_extended_string(len);

    for (cl_index i = 0;  i < u32.length();  ++i) {
        lisp32->string.self[i] = u32.at(i);
    }

//    FILE *f = CPathOpen ("/Users/miyako/Desktop/stdout", CPathCreate);
//
//    if(f)
//    {
//        ecl_setq(ecl_process_env(),
//                 ecl_make_symbol("*STANDARD-OUTPUT*", "COMMON-LISP"),
//                 ecl_make_stream_from_FILE(ecl_make_constant_base_string("stdout", -1),
//                                           f,
//                                           ecl_smm_output,
//                                           8,
//                                           0,
//                                           ecl_make_keyword("UTF-8")));
//    }
  
    cl_object os = ecl_make_string_output_stream(4096, 1);
    cl_object es = ecl_make_string_output_stream(4096, 1);
    
    ecl_setq(ecl_process_env(),
             ecl_make_symbol("*STANDARD-OUTPUT*", "COMMON-LISP"),
             os);
    
    ecl_setq(ecl_process_env(),
             ecl_make_symbol("*ERROR-OUTPUT*", "COMMON-LISP"),
             es);
    
    cl_object form = si_string_to_object(1, lisp32);
    
    cl_object error = NULL;
    
    si_safe_eval(3, form, ECL_NIL, error);
    
    if(!error) {
        ob_set_b(status, L"success", true);
    }

    get_output(status, L"stdout", os);
    get_output(status, L"stderr", es);

//    if(f) {
//        fclose(f);
//    }
            
    PA_ReturnObject(params, status);
}

#pragma mark -

static void u16_to_u8(CUTF16String& u16, std::string& u8) {
    
#ifdef _WIN32
    int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)u16.c_str(), u16.length(), NULL, 0, NULL, NULL);
    
    if(len){
        std::vector<uint8_t> buf(len + 1);
        if(WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)u16.c_str(), u16.length(), (LPSTR)&buf[0], len, NULL, NULL)){
            u8 = std::string((const char *)&buf[0]);
        }
    }else{
        u8 = std::string((const char *)"");
    }

#else
    CFStringRef str = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar *)u16.c_str(), u16.length());
    if(str){
        size_t size = CFStringGetMaximumSizeForEncoding(CFStringGetLength(str), kCFStringEncodingUTF8) + sizeof(uint8_t);
        std::vector<uint8_t> buf(size);
        CFIndex len = 0;
        CFStringGetBytes(str, CFRangeMake(0, CFStringGetLength(str)), kCFStringEncodingUTF8, 0, true, (UInt8 *)&buf[0], size, &len);
        u8 = std::string((const char *)&buf[0], len);
        CFRelease(str);
    }
#endif
}

static void u8_to_u16(std::string& u8, CUTF16String& u16) {
    
#ifdef _WIN32
    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)u8.c_str(), u8.length(), NULL, 0);
    
    if(len){
        std::vector<uint8_t> buf((len + 1) * sizeof(PA_Unichar));
        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)u8.c_str(), u8.length(), (LPWSTR)&buf[0], len)){
            u16 = CUTF16String((const PA_Unichar *)&buf[0]);
        }
    }else{
        u16 = CUTF16String((const PA_Unichar *)L"");
    }
    
#else
    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)u8.c_str(), u8.length(), kCFStringEncodingUTF8, true);
    if(str){
        CFIndex len = CFStringGetLength(str);
        std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
        CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
        u16 = CUTF16String((const PA_Unichar *)&buf[0]);
        CFRelease(str);
    }
#endif
}
